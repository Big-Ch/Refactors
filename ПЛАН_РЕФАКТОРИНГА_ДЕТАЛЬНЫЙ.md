# План рефакторинга проекта OnlineShop

## Общая информация о проекте

Проект представляет собой веб-приложение на Spring Boot 2.3.6 для онлайн-магазина шаурмы. Приложение использует:
- Spring Boot 2.3.6.RELEASE
- Spring Security для аутентификации
- PostgreSQL в качестве БД
- Thymeleaf для представлений
- JPA/Hibernate для работы с данными
- Flyway для миграций БД
- Lombok для уменьшения boilerplate кода
- ModelMapper для маппинга DTO

---

## ИТЕРАЦИЯ 1: КРИТИЧЕСКИЕ ПРОБЛЕМЫ БЕЗОПАСНОСТИ И КОНФИГУРАЦИИ

### Цель итерации
Устранение критических проблем безопасности, конфигурации и базовых проблем качества кода, которые могут привести к проблемам в production окружении.

### Задачи

#### Задача 1.1: Рефакторинг конфигурации и вынос чувствительных данных

**Цель:** Устранение жестко прописанных путей и конфиденциальных данных из кода

**Что подлежит рефакторингу:**
- `src/main/resources/application.properties`
- `pom.xml`

**Проблемы:**
1. Абсолютный путь к директории загрузки файлов: `upload.path=/C:/Users/vccha/Desktop/DB/OnlineShop-master/src/main/resources/uploads`
2. Пароль базы данных в открытом виде: `spring.datasource.password=12345`
3. Учетные данные email в открытом виде: `spring.mail.username=vezhur2003@gmail.com`, `spring.mail.password=K!-iq62Bv`
4. Секретный ключ reCAPTCHA в открытом виде: `recaptcha.secret=6Lc5cLkZAAAAANUjd4--Jx6PioSC_N-9MFKT3PsA`
5. Жестко прописанный путь к Java компилятору в `pom.xml`: `<executable>C:\Program Files\Java\jdk1.8.0_251\bin\javac.exe</executable>`

**Решения:**
1. Заменить абсолютный путь на относительный или использовать системные свойства (`${user.home}/uploads` или `classpath:uploads`)
2. Вынести пароль БД в переменную окружения: `spring.datasource.password=${DB_PASSWORD:12345}`
3. Вынести учетные данные email в переменные окружения: `spring.mail.username=${MAIL_USERNAME}`, `spring.mail.password=${MAIL_PASSWORD}`
4. Вынести reCAPTCHA secret в переменную окружения: `recaptcha.secret=${RECAPTCHA_SECRET}`
5. Удалить жестко прописанный путь к Java компилятору из `pom.xml`
6. Создать профили конфигурации (dev, prod) с использованием `application-dev.properties` и `application-prod.properties`

**Ожидаемый результат:**
- Приложение работает с относительными путями
- Все конфиденциальные данные вынесены в переменные окружения
- Упрощение развертывания на разных машинах и окружениях
- Соответствие best practices безопасности

---

#### Задача 1.2: Исправление обработки исключений и удаление @SneakyThrows

**Цель:** Замена скрытой обработки исключений на явную

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/AdminServiceImpl.java`

**Проблемы:**
1. Использование `@SneakyThrows` в методах `editShawarma()` и `addShawarma()` скрывает проверяемые исключения
2. Метод `saveShawarma()` объявлен с `throws IOException`, но используется `@SneakyThrows` на вызывающих методах
3. Нет обработки ошибок загрузки файлов
4. Нет кастомных исключений для специфических ошибок

**Решения:**
1. Удалить аннотацию `@SneakyThrows` из методов `editShawarma()` и `addShawarma()`
2. Добавить явное объявление `throws IOException` или обработку исключений
3. Создать кастомное исключение `FileUploadException` для ошибок загрузки файлов
4. Создать `@ControllerAdvice` класс `GlobalExceptionHandler` для централизованной обработки исключений
5. Обработать `FileUploadException`, `ResponseStatusException` и другие стандартные исключения

**Ожидаемый результат:**
- Все исключения обрабатываются явно
- Единообразная обработка ошибок во всем приложении
- Улучшенная читаемость и поддерживаемость кода
- Лучшая отладка проблем

---

#### Задача 1.3: Удаление отладочного кода

**Цель:** Удаление `System.out.println` из production кода

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/controller/AdminController.java`

**Проблемы:**
1. Строка `System.out.println(shawarma);` в методе `addShawarma()` (строка 97)

**Решения:**
1. Удалить строку `System.out.println(shawarma);`
2. При необходимости заменить на логирование через SLF4J с уровнем DEBUG

**Ожидаемый результат:**
- Чистый production код без отладочных выводов
- При необходимости - структурированное логирование

---

#### Задача 1.4: Выделение файлового сервиса

**Цель:** Разделение ответственности: бизнес-логика отделена от файловых операций

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/AdminServiceImpl.java`

**Проблемы:**
1. Файловые операции смешаны с бизнес-логикой в методе `saveShawarma()`
2. Нет валидации загружаемых файлов (размер, тип)
3. Логика работы с файлами не переиспользуется
4. Сложно тестировать файловые операции

**Решения:**
1. Создать интерфейс `FileService` с методами:
   - `String saveFile(MultipartFile file) throws FileUploadException`
   - `void deleteFile(String filename) throws FileUploadException`
   - `boolean fileExists(String filename)`
2. Создать реализацию `FileServiceImpl` с логикой сохранения и удаления файлов
3. Перенести логику работы с файлами из `AdminServiceImpl.saveShawarma()` в `FileService`
4. Добавить валидацию загружаемых файлов:
   - Проверка размера файла (max 10MB)
   - Проверка типа файла (только изображения: jpg, png, jpeg)
   - Проверка имени файла на безопасность

**Ожидаемый результат:**
- Разделение ответственности: бизнес-логика отделена от файловых операций
- Возможность повторного использования файлового сервиса
- Улучшенная тестируемость
- Безопасная обработка файлов

---

#### Задача 1.5: Исправление использования устаревших методов JPA

**Цель:** Замена устаревшего `getOne()` на `findById()`

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/CartServiceImpl.java`

**Проблемы:**
1. Использование устаревшего метода `shawarmaRepository.getOne(shawarmaId)` (строки 31 и 39)
2. `getOne()` возвращает прокси без проверки существования сущности
3. Может привести к `LazyInitializationException` или `EntityNotFoundException`

**Решения:**
1. Заменить `shawarmaRepository.getOne(shawarmaId)` на `shawarmaRepository.findById(shawarmaId).orElseThrow(...)`
2. Добавить обработку случая, когда шаурма не найдена
3. Использовать кастомное исключение `EntityNotFoundException`

**Ожидаемый результат:**
- Использование актуальных методов JPA
- Корректная обработка отсутствующих сущностей
- Избежание `LazyInitializationException`

---

#### Задача 1.6: Включение CSRF защиты

**Цель:** Повышение безопасности приложения

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/configuration/WebSecurityConfiguration.java`

**Проблемы:**
1. CSRF защита отключена: `.csrf().disable()` (строка 46)
2. Приложение уязвимо к CSRF атакам

**Решения:**
1. Удалить `.csrf().disable()`
2. Добавить `csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())` для поддержки REST API
3. Обновить Thymeleaf формы для включения CSRF токенов (использовать `th:action` вместо `action`)
4. Протестировать все формы на корректную работу с CSRF

**Ожидаемый результат:**
- Защита от CSRF атак
- Безопасная работа всех форм
- Соответствие best practices безопасности

---

## ИТЕРАЦИЯ 2: УСТРАНЕНИЕ ДУБЛИРОВАНИЯ И УЛУЧШЕНИЕ АРХИТЕКТУРЫ

### Цель итерации
Устранение дублирования кода, улучшение архитектуры приложения и повышение переиспользуемости компонентов.

### Задачи

#### Задача 2.1: Создание сервиса валидации паролей

**Цель:** Устранение дублирования логики валидации паролей

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/UserServiceImpl.java` (строка 58)
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/AuthenticationServiceImpl.java` (строка 53)
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/RegistrationServiceImpl.java` (строка 44)

**Проблемы:**
1. Дублирование логики проверки совпадения паролей в трех сервисах: `if (request.getPassword() != null && !request.getPassword().equals(request.getPassword2()))`
2. Логика валидации разбросана по разным местам
3. Сложно изменить правила валидации паролей

**Решения:**
1. Создать интерфейс `PasswordValidationService` с методами:
   - `void validatePasswordsMatch(String password, String password2) throws ValidationException`
   - `void validatePasswordStrength(String password) throws ValidationException`
2. Реализовать `PasswordValidationServiceImpl` с единой логикой проверки:
   - Проверка совпадения паролей
   - Возможность добавления правил силы пароля (опционально)
3. Заменить дублированный код проверки `password.equals(password2)` в трех сервисах на вызов `PasswordValidationService`
4. Использовать кастомное исключение `ValidationException` для ошибок валидации

**Ожидаемый результат:**
- Единая точка валидации паролей
- Упрощение добавления новых правил валидации
- Снижение риска ошибок при изменении логики валидации
- Улучшенная поддерживаемость

---

#### Задача 2.2: Рефакторинг MailService - управление ExecutorService

**Цель:** Правильное управление ресурсами ExecutorService

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/MailService.java`

**Проблемы:**
1. Создание нового `ExecutorService` при каждом вызове `sendMessageHtml()` (строка 31)
2. Нет правильного завершения ExecutorService (только `shutdown()`, нет `awaitTermination()`)
3. Риск утечки ресурсов при большом количестве запросов
4. Нет обработки исключений при отправке email

**Решения:**
1. Создать `ExecutorService` как bean компонент с аннотацией `@Bean(destroyMethod = "shutdown")`
2. Инжектировать `ExecutorService` в `MailService` вместо создания нового при каждом вызове
3. Использовать `@Async` от Spring для асинхронной отправки email
4. Добавить логирование ошибок отправки email
5. Обработать исключения отправки email

**Ожидаемый результат:**
- Правильное управление ресурсами
- Избежание утечек памяти
- Улучшенная производительность
- Правильная обработка ошибок

---

#### Задача 2.3: Создание централизованного DTO маппера

**Цель:** Централизация маппинга DTO и улучшение контроля над преобразованиями

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/AdminServiceImpl.java`
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/OrderServiceImpl.java`
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/RegistrationServiceImpl.java`

**Проблемы:**
1. Прямое использование `ModelMapper` в сервисах
2. Логика маппинга разбросана по разным сервисам
3. Нет контроля над кастомными преобразованиями
4. Сложно тестировать маппинг

**Решения:**
1. Создать класс `DtoMapper` с методами для преобразования между DTO и Entity:
   - `Shawarma toEntity(ShawarmaRequest request)`
   - `Order toEntity(OrderRequest request, User user)`
   - `User toEntity(UserRequest request)`
   - И обратные преобразования при необходимости
2. Перенести логику маппинга из сервисов в `DtoMapper`
3. Использовать `ModelMapper` внутри `DtoMapper` или кастомную логику
4. Добавить кастомные методы маппинга для сложных случаев

**Ожидаемый результат:**
- Централизованная логика преобразования
- Улучшенный контроль над маппингом
- Упрощение тестирования
- Единообразный подход к маппингу

---

#### Задача 2.4: Рефакторинг ControllerUtils

**Цель:** Улучшение читаемости и разделение ответственности

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/utils/ControllerUtils.java`

**Проблемы:**
1. Класс содержит слишком много различных функций:
   - Валидация полей
   - Пагинация
   - Установка сообщений
2. Метод `computePagination()` сложный и плохо читаемый
3. Нет JavaDoc комментариев
4. Метод `getErrors()` создает коллектор, который используется только один раз

**Решения:**
1. Разделить `ControllerUtils` на специализированные классы:
   - `PaginationUtils` - для работы с пагинацией
   - `ValidationUtils` - для работы с валидацией
   - `ModelUtils` - для работы с Model атрибутами
2. Улучшить читаемость метода `computePagination()`:
   - Разбить на более мелкие методы
   - Добавить комментарии
   - Упростить логику
3. Добавить JavaDoc комментарии ко всем публичным методам
4. Упростить метод `getErrors()` - использовать прямую коллекцию

**Ожидаемый результат:**
- Более четкое разделение ответственности
- Улучшенная читаемость и поддерживаемость
- Лучшая организация кода
- Документированный код

---

#### Задача 2.5: Улучшение CommonErrorController

**Цель:** Улучшение обработки ошибок и соответствие современным стандартам Spring Boot

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/controller/CommonErrorController.java`

**Проблемы:**
1. Использование устаревшего метода `getErrorPath()` (deprecated в Spring Boot 2.3+)
2. Базовая реализация обработки ошибок
3. Нет логирования ошибок
4. Не интегрирован с `GlobalExceptionHandler`

**Решения:**
1. Удалить метод `getErrorPath()` (больше не требуется в Spring Boot 2.3+)
2. Улучшить логирование ошибок с помощью SLF4J
3. Добавить обработку различных типов ошибок (403, 500, и т.д.)
4. Интегрировать с `GlobalExceptionHandler` для единообразной обработки
5. Добавить более детальную информацию об ошибках (для dev окружения)

**Ожидаемый результат:**
- Соответствие актуальным стандартам Spring Boot
- Более информативная обработка ошибок
- Правильное логирование
- Единообразная обработка ошибок

---

## ИТЕРАЦИЯ 3: СОЗДАНИЕ КАСТОМНЫХ ИСКЛЮЧЕНИЙ И ОБРАБОТКА ОШИБОК

### Цель итерации
Создание иерархии кастомных исключений и улучшение обработки ошибок во всем приложении.

### Задачи

#### Задача 3.1: Создание кастомных исключений

**Цель:** Создание иерархии кастомных исключений для лучшей обработки ошибок

**Что подлежит рефакторингу:**
- Все сервисные классы, использующие `ResponseStatusException`

**Проблемы:**
1. Использование `ResponseStatusException` напрямую в сервисах
2. Нет явной семантики исключений
3. Сложно различать типы ошибок
4. Нет возможности для специфической обработки различных типов ошибок

**Решения:**
1. Создать пакет `exception` со следующей иерархией:
   - `BusinessLogicException` (базовое исключение) - абстрактный класс
   - `EntityNotFoundException extends BusinessLogicException` - для случаев, когда сущность не найдена
   - `ValidationException extends BusinessLogicException` - для ошибок валидации
   - `FileUploadException extends BusinessLogicException` - для ошибок загрузки файлов
   - `AuthenticationException extends BusinessLogicException` - для ошибок аутентификации
2. Заменить `ResponseStatusException` на кастомные исключения в сервисах:
   - `AdminServiceImpl` - использовать `EntityNotFoundException`
   - `ShawarmaServiceImpl` - использовать `EntityNotFoundException`
   - `UserServiceImpl` - использовать `ValidationException`
   - И т.д.
3. Обновить `GlobalExceptionHandler` для обработки новых исключений
4. Добавить соответствующие HTTP статусы для каждого типа исключения

**Ожидаемый результат:**
- Явная семантика исключений
- Улучшенная обработка ошибок
- Легче отлавливать и обрабатывать специфические ошибки
- Лучшая читаемость кода

---

#### Задача 3.2: Создание GlobalExceptionHandler

**Цель:** Централизованная обработка всех исключений

**Что подлежит рефакторингу:**
- Создание нового класса

**Проблемы:**
1. Нет централизованной обработки исключений
2. Каждый контроллер обрабатывает исключения по-своему
3. Нет единообразного формата ответов об ошибках

**Решения:**
1. Создать класс `GlobalExceptionHandler` с аннотацией `@ControllerAdvice`
2. Добавить методы обработки для каждого типа исключения:
   - `@ExceptionHandler(EntityNotFoundException.class)` - 404
   - `@ExceptionHandler(ValidationException.class)` - 400
   - `@ExceptionHandler(FileUploadException.class)` - 500
   - `@ExceptionHandler(AuthenticationException.class)` - 401
   - `@ExceptionHandler(Exception.class)` - 500 (fallback)
3. Для каждого типа исключения возвращать соответствующую страницу ошибки
4. Добавить логирование всех исключений с уровнем ERROR
5. В dev окружении добавлять детальную информацию об ошибке

**Ожидаемый результат:**
- Единообразная обработка ошибок
- Централизованное логирование исключений
- Улучшенный пользовательский опыт
- Упрощение обработки ошибок в контроллерах

---

## ИТЕРАЦИЯ 4: ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ И БАЗЫ ДАННЫХ

### Цель итерации
Оптимизация запросов к БД, устранение N+1 проблем и улучшение производительности приложения.

### Задачи

#### Задача 4.1: Анализ и оптимизация запросов к БД

**Цель:** Устранение N+1 проблем и оптимизация загрузки связанных сущностей

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/repository/UserRepository.java`
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/repository/OrderRepository.java`
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/repository/ShawarmaRepository.java`
- Сущности: `User.java`, `Order.java`, `Shawarma.java`

**Проблемы:**
1. Потенциальная N+1 проблема при загрузке `User` с `shawarmaList`
2. Не определены стратегии загрузки для связей `@ManyToMany`
3. Нет `@EntityGraph` для оптимизации некоторых запросов
4. В `Order` связь `@ManyToMany` с `Shawarma` может вызывать N+1

**Решения:**
1. Провести анализ запросов с помощью логирования SQL (`spring.jpa.show-sql=true`)
2. Для `User.shawarmaList` установить `FetchType.LAZY` (если не установлено)
3. Добавить `@EntityGraph` для методов, которым нужны связанные сущности:
   - `UserRepository.findByIdWithShawarmas()`
   - `OrderRepository.findByIdWithShawarmas()`
4. Оптимизировать запросы в сервисах для использования `@EntityGraph`
5. Добавить индексы через миграции Flyway:
   - Индекс на `users.email`
   - Индекс на `orders.user_id`
   - Индекс на `shawarmas.category`
   - Индекс на `shawarmas.price`
6. Проверить стратегии загрузки для всех `@ManyToMany` и `@ManyToOne` связей

**Ожидаемый результат:**
- Устранение N+1 проблем
- Улучшенная производительность запросов
- Оптимизация использования памяти
- Быстрая работа приложения при больших объемах данных

---

#### Задача 4.2: Оптимизация метода getPopularShawarmas

**Цель:** Улучшение производительности получения популярных шаурм

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/ShawarmaServiceImpl.java`

**Проблемы:**
1. Жестко прописанные ID шаурм: `Arrays.asList(1L, 2L, 3L, ...)`
2. Нет логики определения популярности (на основе заказов)
3. Сложно изменять список популярных шаурм

**Решения:**
1. Реализовать логику определения популярности на основе количества заказов:
   - Создать метод в `OrderRepository`: `findMostOrderedShawarmas(limit)`
   - Использовать группировку и подсчет заказов
2. Добавить конфигурационный параметр для лимита популярных шаурм: `app.popular-shawarmas.limit=12`
3. Заменить жестко прописанные ID на динамический запрос
4. Добавить кеширование популярных шаурм (Spring Cache) на 1 час

**Ожидаемый результат:**
- Динамическое определение популярности
- Улучшенная производительность за счет кеширования
- Гибкая конфигурация
- Соответствие реальной популярности продуктов

---

## ИТЕРАЦИЯ 5: УЛУЧШЕНИЕ ВАЛИДАЦИИ И ЛОГИРОВАНИЯ

### Цель итерации
Улучшение валидации входных данных и добавление структурированного логирования.

### Задачи

#### Задача 5.1: Улучшение валидации DTO

**Цель:** Более надежная валидация входных данных

**Что подлежит рефакторингу:**
- Все DTO классы в `src/main/java/com/gmail/v/c/charkin/gurmanfood/dto/request/`

**Проблемы:**
1. Неполная валидация в некоторых DTO:
   - `EditUserRequest` - нет валидации формата телефона
   - `OrderRequest` - нет валидации формата телефона
   - `ShawarmaRequest` - нет валидации диапазона цены
2. Нет кастомных валидаторов для сложных случаев
3. Повторяющиеся сообщения об ошибках

**Решения:**
1. Добавить валидацию формата телефона:
   - Создать кастомный валидатор `@PhoneNumber` для российских телефонов
   - Применить к полям `phoneNumber` в `EditUserRequest` и `OrderRequest`
2. Добавить валидацию диапазона цены в `ShawarmaRequest`:
   - `@Min(value = 1)`
   - `@Max(value = 100000)`
3. Добавить валидацию длины для текстовых полей:
   - `@Length(min = 1, max = 255)` для всех текстовых полей
4. Создать кастомный валидатор для проверки формата email (если нужна дополнительная проверка)
5. Группировать сообщения об ошибках в константы

**Ожидаемый результат:**
- Более надежная валидация данных
- Лучшая защита от некорректных данных
- Улучшенный пользовательский опыт
- Единообразные сообщения об ошибках

---

#### Задача 5.2: Добавление структурированного логирования

**Цель:** Добавление логирования для отладки и мониторинга

**Что подлежит рефакторингу:**
- Все сервисные классы
- Контроллеры (при необходимости)

**Проблемы:**
1. Нет логирования в приложении (кроме настроенного в `application.properties`)
2. Сложно отслеживать работу приложения
3. Нет логирования важных бизнес-событий
4. Нет логирования ошибок с контекстом

**Решения:**
1. Добавить логирование в ключевые точки приложения:
   - Вход/выход из методов сервисов (уровень DEBUG)
   - Важные бизнес-события (уровень INFO):
     - Создание заказа
     - Регистрация пользователя
     - Сброс пароля
     - Добавление/редактирование шаурмы
   - Ошибки и исключения (уровень ERROR)
2. Использовать SLF4J с соответствующими уровнями логирования
3. Добавлять контекстную информацию в логи:
   - ID пользователя
   - ID заказа
   - Параметры запроса
4. Настроить конфигурацию логирования в `application.properties`:
   - Уровни логирования для разных пакетов
   - Формат логов
   - Ротация логов

**Ожидаемый результат:**
- Улучшенная наблюдаемость приложения
- Упрощение отладки
- Возможность мониторинга работы приложения
- Трассировка важных событий

---

## ИТЕРАЦИЯ 6: УЛУЧШЕНИЕ АРХИТЕКТУРЫ И КОДА

### Цель итерации
Финальная оптимизация кода, улучшение читаемости и подготовка к дальнейшему развитию проекта.

### Задачи

#### Задача 6.1: Рефакторинг Security конфигурации

**Цель:** Улучшение безопасности и современный подход к конфигурации

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/configuration/WebSecurityConfiguration.java`

**Проблемы:**
1. Использование устаревшего `WebSecurityConfigurerAdapter` (deprecated в Spring Security 5.7+)
2. Захардкоженные пути в конфигурации
3. Нет разделения конфигурации для dev и prod окружений

**Решения:**
1. Перейти на новый подход конфигурации Spring Security (без `WebSecurityConfigurerAdapter`):
   - Создать `SecurityFilterChain` bean
   - Использовать `HttpSecurity` напрямую
2. Вынести публичные пути в константы или отдельный класс конфигурации
3. Добавить более детальную настройку CORS (если требуется)
4. Настроить обработку ошибок аутентификации
5. Добавить rate limiting для защиты от брутфорса (опционально)

**Ожидаемый результат:**
- Современный подход к конфигурации Spring Security
- Более гибкая конфигурация безопасности
- Соответствие актуальным версиям Spring Security

---

#### Задача 6.2: Рефакторинг UserPrincipal

**Цель:** Улучшение реализации UserPrincipal

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/security/UserPrincipal.java`

**Проблемы:**
1. Метод `create()` использует `user.getRoles().iterator().next()` - берет только первую роль
2. Не учитывает множественные роли пользователя
3. Использование `@Data` на классе, который содержит final поля (избыточно)

**Решения:**
1. Исправить метод `create()` для поддержки множественных ролей:
   - Преобразовать все роли в `GrantedAuthority`
   - Использовать `stream().map()` для преобразования
2. Заменить `@Data` на явные getters (если нужны) или оставить только final поля
3. Убедиться, что все методы корректно работают с множественными ролями

**Ожидаемый результат:**
- Поддержка множественных ролей
- Корректная работа аутентификации
- Более гибкая система ролей

---

#### Задача 6.3: Улучшение обработки корзины

**Цель:** Оптимизация работы с корзиной

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/service/impl/CartServiceImpl.java`
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/domain/User.java`

**Проблемы:**
1. Корзина хранится в БД как связь `@ManyToMany` в `User.shawarmaList`
2. Каждое изменение корзины приводит к обновлению БД
3. Нет валидации при добавлении товара в корзину (например, проверка наличия)

**Решения:**
1. Рассмотреть вариант хранения корзины в сессии или Redis (опционально)
2. Если оставляем в БД, оптимизировать:
   - Добавить проверку наличия товара перед добавлением
   - Добавить проверку дубликатов
   - Оптимизировать запросы загрузки корзины
3. Добавить валидацию:
   - Проверка существования шаурмы
   - Проверка доступности шаурмы
4. Добавить логирование операций с корзиной

**Ожидаемый результат:**
- Более эффективная работа с корзиной
- Валидация операций
- Лучшая производительность

---

#### Задача 6.4: Рефакторинг EmailConfiguration

**Цель:** Упрощение конфигурации email

**Что подлежит рефакторингу:**
- `src/main/java/com/gmail/v/c/charkin/gurmanfood/configuration/EmailConfiguration.java`

**Проблемы:**
1. Дублирование конфигурации - Spring Boot уже поддерживает автоконфигурацию email
2. Избыточный код для стандартной конфигурации
3. Можно использовать `spring.mail.*` свойства напрямую

**Решения:**
1. Проверить, можно ли удалить `EmailConfiguration` и использовать автоконфигурацию Spring Boot
2. Если требуется кастомная конфигурация, упростить класс:
   - Использовать `@ConfigurationProperties` для биндинга свойств
   - Убрать дублирование с `application.properties`
3. Оставить только необходимую кастомную логику

**Ожидаемый результат:**
- Упрощенная конфигурация
- Меньше boilerplate кода
- Использование стандартных возможностей Spring Boot

---

#### Задача 6.5: Добавление JavaDoc документации

**Цель:** Документирование кода для улучшения поддерживаемости

**Что подлежит рефакторингу:**
- Все публичные классы и методы

**Проблемы:**
1. Отсутствие JavaDoc комментариев
2. Сложно понять назначение методов без изучения реализации
3. Нет описания параметров и возвращаемых значений

**Решения:**
1. Добавить JavaDoc комментарии ко всем публичным классам:
   - Описание назначения класса
   - Примеры использования (при необходимости)
2. Добавить JavaDoc комментарии ко всем публичным методам:
   - Описание назначения метода
   - Описание параметров (`@param`)
   - Описание возвращаемых значений (`@return`)
   - Описание исключений (`@throws`)
3. Добавить JavaDoc для сложных приватных методов
4. Использовать стандартный формат JavaDoc

**Ожидаемый результат:**
- Документированный код
- Улучшенная поддерживаемость
- Легче понять назначение классов и методов
- Готовность к дальнейшей разработке

---

#### Задача 6.6: Финальная проверка и оптимизация

**Цель:** Финальная проверка качества кода

**Что подлежит рефакторингу:**
- Все измененные файлы

**Проблемы:**
1. Возможные неиспользуемые импорты
2. Несоответствие код-стайлу
3. Возможные дублирования кода
4. Отсутствие тестов

**Решения:**
1. Проверить и удалить неиспользуемые импорты
2. Проверить соответствие код-стайлу проекта (использовать Checkstyle или подобные инструменты)
3. Проверить на дублирование кода (использовать инструменты статического анализа)
4. Рассмотреть добавление unit-тестов для критичных компонентов:
   - Сервисы
   - Валидаторы
   - Мапперы
5. Создать краткий README с описанием архитектуры проекта

**Ожидаемый результат:**
- Чистый и качественный код
- Соответствие стандартам кодирования
- Готовность к дальнейшему развитию
- Возможность добавления тестов

---

## ИТОГОВЫЙ СПИСОК ВСЕГО, ЧТО ПОДЛЕЖИТ РЕФАКТОРИНГУ

### Критические проблемы безопасности и конфигурации

1. ✅ **application.properties** - жестко прописанные пути и пароли
2. ✅ **pom.xml** - жестко прописанный путь к Java компилятору
3. ✅ **AdminServiceImpl** - использование @SneakyThrows, смешивание логики с файловыми операциями
4. ✅ **AdminController** - System.out.println в production коде
5. ✅ **CartServiceImpl** - использование устаревшего getOne()
6. ✅ **WebSecurityConfiguration** - отключенная CSRF защита

### Проблемы дублирования кода

7. ✅ **UserServiceImpl** - дублирование валидации паролей
8. ✅ **AuthenticationServiceImpl** - дублирование валидации паролей
9. ✅ **RegistrationServiceImpl** - дублирование валидации паролей
10. ✅ **MailService** - неправильное управление ExecutorService
11. ✅ **AdminServiceImpl, OrderServiceImpl, RegistrationServiceImpl** - прямое использование ModelMapper

### Проблемы архитектуры

12. ✅ **ControllerUtils** - слишком много ответственности, сложные методы
13. ✅ **CommonErrorController** - устаревший метод getErrorPath()
14. ✅ **Все сервисы** - использование ResponseStatusException вместо кастомных исключений
15. ✅ **Отсутствует GlobalExceptionHandler** - нет централизованной обработки исключений
16. ✅ **Отсутствует FileService** - файловые операции в бизнес-логике
17. ✅ **Отсутствует PasswordValidationService** - валидация разбросана по коду
18. ✅ **Отсутствует DtoMapper** - маппинг разбросан по сервисам

### Проблемы производительности

19. ✅ **Все репозитории** - потенциальные N+1 проблемы
20. ✅ **ShawarmaServiceImpl.getPopularShawarmas()** - жестко прописанные ID
21. ✅ **User.shawarmaList, Order.shawarmas** - не оптимизированные связи
22. ✅ **Отсутствуют индексы БД** - нет оптимизации запросов

### Проблемы валидации и логирования

23. ✅ **Все DTO** - неполная валидация (формат телефона, диапазоны)
24. ✅ **Все сервисы** - отсутствует логирование
25. ✅ **Отсутствуют кастомные валидаторы** - нет валидации сложных случаев

### Проблемы кода и документации

26. ✅ **WebSecurityConfiguration** - устаревший WebSecurityConfigurerAdapter
27. ✅ **UserPrincipal** - неправильная обработка множественных ролей
28. ✅ **CartServiceImpl** - нет валидации при работе с корзиной
29. ✅ **EmailConfiguration** - избыточная конфигурация
30. ✅ **Все классы** - отсутствие JavaDoc документации

---

## КРИТЕРИИ УСПЕХА

После завершения всех итераций рефакторинга ожидаются следующие улучшения:

### Безопасность
- ✅ Все конфиденциальные данные вынесены в переменные окружения
- ✅ Включена CSRF защита
- ✅ Улучшена валидация входных данных
- ✅ Безопасная обработка файлов

### Качество кода
- ✅ Устранено дублирование кода
- ✅ Улучшена читаемость и поддерживаемость
- ✅ Явная обработка исключений
- ✅ Разделение ответственности между компонентами

### Архитектура
- ✅ Четкое разделение слоев (Controller, Service, Repository)
- ✅ Переиспользуемые компоненты
- ✅ Централизованная обработка ошибок
- ✅ Улучшенная тестируемость

### Производительность
- ✅ Оптимизированные запросы к БД
- ✅ Минимизация N+1 проблем
- ✅ Эффективное использование ресурсов
- ✅ Кеширование при необходимости

### Поддерживаемость
- ✅ Документированный код
- ✅ Структурированное логирование
- ✅ Готовность к дальнейшему развитию
- ✅ Соответствие best practices

---

**Дата создания плана:** 2024  
**Версия:** 2.0  
**Статус:** Готов к реализации

