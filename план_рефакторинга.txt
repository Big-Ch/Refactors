План рефакторинга
Итерация 1: Устранение критических уязвимостей и базовых проблем
Цель: Стабилизировать проект, закрыть основные уязвимости в безопасности и конфигурации, а также исправить наиболее очевидные проблемы в коде для обеспечения безопасной и предсказуемой работы приложения.
Задачи:
1.	Задача: Рефакторинг конфигурации
•	Что делаем: Выносим все чувствительные данные (пароли, ключи API) из application.properties в переменные окружения и заменяем абсолютные пути на относительные.
•	Зачем это делать?
•	Безопасность: Хранение паролей и ключей в коде — это критическая уязвимость. Любой, кто получит доступ к исходному коду, сможет скомпрометировать систему. Вынос секретов в окружение — стандартная практика безопасности.
•	Гибкость развертывания: Жестко прописанные пути (например, C:/Users/...) не позволят запустить приложение нигде, кроме машины разработчика. Использование переменных окружения и относительных путей делает приложение переносимым и готовым к развертыванию на любом сервере или в Docker-контейнере.
2.	Задача: Включение CSRF-защиты
•	Что делаем: Активируем CSRF-защиту в Spring Security, которая по умолчанию была отключена (.csrf().disable()).
•	Зачем это делать?
•	Защита пользователей: Отключенная CSRF (Cross-Site Request Forgery) защита делает пользователей уязвимыми для атак. Злоумышленник может заставить браузер аутентифицированного пользователя выполнить нежелательные действия (например, оформить заказ или изменить данные профиля) без его ведома. Включение защиты — это базовое требование для безопасного веб-приложения.
3.	Задача: Корректная обработка исключений
•	Что делаем: Заменяем использование @SneakyThrows на явную обработку исключений (try-catch или throws).
•	Зачем это делать?
•	Предсказуемость и надежность: @SneakyThrows "прячет" проверяемые исключения, делая поведение метода непредсказуемым. Разработчик, вызывающий такой метод, не знает, какие ошибки могут произойти. Явная обработка заставляет продумывать сценарии сбоев, что делает приложение более стабильным и отказоустойчивым.
4.	Задача: Выделение файлового сервиса (FileService)
•	Что делаем: Изолируем логику загрузки, сохранения и валидации файлов из бизнес-сервиса (AdminServiceImpl) в отдельный компонент FileService.
•	Зачем это делать?
•	Разделение ответственности (Single Responsibility Principle): Бизнес-сервис не должен заниматься техническими деталями файловых операций. Это делает код чище и проще для понимания.
•	Переиспользование и тестируемость: Отдельный FileService можно будет использовать в других частях приложения. Кроме того, его легко тестировать изолированно от бизнес-логики.
5.	Задача: Актуализация работы с JPA
•	Что делаем: Заменяем устаревший метод getOne() на современный и безопасный findById().orElseThrow().
•	Зачем это делать?
•	Предотвращение скрытых ошибок: Метод getOne() не выполняет запрос к БД немедленно и может вернуть прокси-объект. Это часто приводит к ошибке EntityNotFoundException в неожиданном месте, когда происходит реальное обращение к данным. findById() сразу проверяет наличие сущности и позволяет немедленно обработать случай, когда она не найдена, делая код более надежным.
Итерация 2: Улучшение архитектуры и устранение дублирования
Цель: Сделать код более модульным, переиспользуемым и поддерживаемым. Централизовать повторяющуюся логику в выделенных компонентах и внедрить единый механизм обработки ошибок.
Задачи:
1.	Задача: Создание GlobalExceptionHandler
•	Что делаем: Внедряем класс с аннотацией @ControllerAdvice для централизованной обработки всех исключений.
•	Зачем это делать?
•	Единообразие и чистота кода: Вместо того чтобы писать блоки try-catch в каждом методе контроллера, мы переносим всю логику обработки ошибок в одно место. Это делает контроллеры более "чистыми" и гарантирует, что все ошибки в приложении обрабатываются одинаково, предоставляя пользователю консистентный опыт.
2.	Задача: Внедрение кастомных исключений
•	Что делаем: Создаем собственные классы исключений (например, EntityNotFoundException) и используем их в сервисах вместо стандартного ResponseStatusException.
•	Зачем это делать?
•	Семантическая ясность: Имя исключения EntityNotFoundException гораздо лучше описывает суть проблемы, чем универсальный ResponseStatusException. Это делает код более читаемым и самодокументируемым.
•	Разделение слоев: Сервисный слой не должен знать о HTTP-статусах. Он должен выбрасывать исключения, описывающие бизнес-проблемы. А GlobalExceptionHandler уже будет преобразовывать их в нужные HTTP-ответы.
3.	Задача: Устранение дублирования логики
•	Что делаем: Создаем PasswordValidationService для проверки паролей и DtoMapper для преобразования DTO в сущности.
•	Зачем это делать?
•	Принцип DRY (Don't Repeat Yourself): Повторяющийся код — источник ошибок. Если логика валидации паролей или маппинга изменится, ее придется исправлять в нескольких местах, и велик риск что-то упустить. Централизация этой логики в одном сервисе решает эту проблему, упрощая поддержку и снижая вероятность ошибок.
4.	Задача: Рефакторинг MailService
•	Что делаем: Оптимизируем управление ExecutorService, создавая его как управляемый Spring bean.
•	Зачем это делать?
•	Предотвращение утечек ресурсов: Создание нового пула потоков (newSingleThreadExecutor) при каждом вызове метода — крайне неэффективно и ведет к утечке ресурсов. Приложение быстро исчерпает память и процессорное время под нагрузкой. Управление ExecutorService через Spring гарантирует, что будет использоваться один общий пул потоков, который корректно завершит свою работу при остановке приложения.
5.	Задача: Реструктуризация утилитных классов
•	Что делаем: Разделяем монолитный ControllerUtils на более мелкие, специализированные классы (PaginationUtils, ValidationUtils).
•	Зачем это делать?
•	Улучшение организации кода: Класс ControllerUtils стал "свалкой" для разных, не связанных друг с другом функций. Разделение на классы с четкой зоной ответственности делает код более структурированным, понятным и легким для навигации.
Итерация 3: Оптимизация производительности и финальная подготовка
Цель: Повысить производительность приложения, особенно в части работы с базой данных, а также внедрить лучшие практики по логированию, валидации и документированию кода, подготовив проект к дальнейшему развитию.
Задачи:
1.	Задача: Оптимизация запросов к БД
•	Что делаем: Анализируем и устраняем проблемы N+1 с помощью @EntityGraph или JOIN FETCH, добавляем индексы в БД.
•	Зачем это делать?
•	Производительность: Проблема N+1 — убийца производительности. Один запрос на получение списка сущностей порождает N дополнительных запросов для загрузки их связей. Это приводит к катастрофическому замедлению работы под нагрузкой. Оптимизация запросов и добавление индексов — ключевой шаг для обеспечения быстрой работы приложения.
2.	Задача: Внедрение структурированного логирования (SLF4J)
•	Что делаем: Добавляем логирование ключевых бизнес-событий и ошибок с помощью стандартного фреймворка логирования.
•	Зачем это делать?
•	Наблюдаемость и отладка: Без логов работающее на сервере приложение — это "черный ящик". Логирование позволяет отслеживать, что происходит внутри системы, быстро диагностировать ошибки в production-среде и анализировать поведение пользователей, не останавливая приложение.
3.	Задача: Усиление валидации DTO
•	Что делаем: Дополняем DTO аннотациями валидации для проверки формата данных (телефон, email) и диапазонов значений (цена).
•	Зачем это делать?
•	Целостность данных: Валидация на "входе" — это первая линия защиты от некорректных данных. Она гарантирует, что в базу данных не попадет "мусор", и защищает систему от ошибок, которые могли бы возникнуть при обработке неверного формата данных.
4.	Задача: Обновление конфигурации Spring Security
•	Что делаем: Переходим на современный подход к конфигурации без использования устаревшего WebSecurityConfigurerAdapter.
•	Зачем это делать?
•	Поддерживаемость и актуальность: Использование устаревших (deprecated) компонентов — это технический долг. Они больше не получают обновлений (включая исправления безопасности) и будут удалены в будущих версиях фреймворка. Переход на современный API гарантирует, что проект останется совместимым и безопасным в долгосрочной перспективе.
5.	Задача: Документирование кода (JavaDoc)
•	Что делаем: Добавляем JavaDoc-комментарии для всех публичных методов и классов.
•	Зачем это делать?
•	Упрощение поддержки: Код пишется один раз, а читается — многократно. Хорошая документация помогает другим разработчикам  быстро понять, что делает тот или иной метод, какие параметры он принимает и что возвращает, не тратя время на изучение его реализации. Это значительно ускоряет разработку и сопровождение проекта.
